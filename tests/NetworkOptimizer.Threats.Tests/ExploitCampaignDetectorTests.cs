using NetworkOptimizer.Threats.Analysis;
using NetworkOptimizer.Threats.Models;
using Xunit;

namespace NetworkOptimizer.Threats.Tests;

public class ExploitCampaignDetectorTests
{
    private readonly ExploitCampaignDetector _detector = new();

    [Fact]
    public void Detect_ThreeSourcesFromSameSubnet_DetectsPattern()
    {
        var events = new List<ThreatEvent>();
        var now = DateTime.UtcNow;

        // 3 different IPs from the same /24, same port + signature, within 1 hour
        for (var i = 1; i <= 3; i++)
        {
            events.Add(new ThreatEvent
            {
                SourceIp = $"198.51.100.{i}",
                DestIp = "192.0.2.1",
                DestPort = 443,
                SignatureId = 2001,
                SignatureName = "Exploit attempt",
                KillChainStage = KillChainStage.AttemptedExploitation,
                Timestamp = now.AddMinutes(-i),
                Action = ThreatAction.Blocked
            });
        }

        var patterns = _detector.Detect(events);

        Assert.Single(patterns);
        Assert.Equal(PatternType.ExploitCampaign, patterns[0].PatternType);
        Assert.Equal(443, patterns[0].TargetPort);
    }

    [Fact]
    public void Detect_TwoSources_NotEnough()
    {
        var events = new List<ThreatEvent>();
        var now = DateTime.UtcNow;

        for (var i = 1; i <= 2; i++)
        {
            events.Add(new ThreatEvent
            {
                SourceIp = $"198.51.100.{i}",
                DestIp = "192.0.2.1",
                DestPort = 22,
                SignatureId = 1001,
                SignatureName = "SSH exploit",
                KillChainStage = KillChainStage.AttemptedExploitation,
                Timestamp = now.AddMinutes(-i),
                Action = ThreatAction.Blocked
            });
        }

        var patterns = _detector.Detect(events);

        Assert.Empty(patterns);
    }

    [Fact]
    public void Detect_DifferentSubnets_NoPattern()
    {
        var events = new List<ThreatEvent>();
        var now = DateTime.UtcNow;

        // 3 sources from different /24 subnets
        events.Add(new ThreatEvent
        {
            SourceIp = "198.51.100.1", DestIp = "192.0.2.1", DestPort = 80, SignatureId = 3001,
            SignatureName = "Web exploit", KillChainStage = KillChainStage.AttemptedExploitation,
            Timestamp = now.AddMinutes(-1), Action = ThreatAction.Blocked
        });
        events.Add(new ThreatEvent
        {
            SourceIp = "198.51.101.1", DestIp = "192.0.2.1", DestPort = 80, SignatureId = 3001,
            SignatureName = "Web exploit", KillChainStage = KillChainStage.AttemptedExploitation,
            Timestamp = now.AddMinutes(-2), Action = ThreatAction.Blocked
        });
        events.Add(new ThreatEvent
        {
            SourceIp = "198.51.102.1", DestIp = "192.0.2.1", DestPort = 80, SignatureId = 3001,
            SignatureName = "Web exploit", KillChainStage = KillChainStage.AttemptedExploitation,
            Timestamp = now.AddMinutes(-3), Action = ThreatAction.Blocked
        });

        var patterns = _detector.Detect(events);

        Assert.Empty(patterns);
    }

    [Fact]
    public void Detect_EmptyEvents_ReturnsEmpty()
    {
        var patterns = _detector.Detect([]);
        Assert.Empty(patterns);
    }

    [Fact]
    public void Detect_NonExploitationStages_ReturnsEmpty()
    {
        var events = new List<ThreatEvent>();
        var now = DateTime.UtcNow;

        // 3 sources from same /24 but in Reconnaissance stage (not exploitation)
        for (var i = 1; i <= 3; i++)
        {
            events.Add(new ThreatEvent
            {
                SourceIp = $"198.51.100.{i}",
                DestIp = "192.0.2.1",
                DestPort = 80,
                SignatureId = 1001,
                SignatureName = "Port scan",
                KillChainStage = KillChainStage.Reconnaissance,
                Timestamp = now.AddMinutes(-i),
                Action = ThreatAction.Detected
            });
        }

        var patterns = _detector.Detect(events);

        Assert.Empty(patterns);
    }
}
